use ast::*;
use std::str::FromStr;

grammar;

pub Module: Vec<Definition> =  {
  <ds: (Def)*> => ds
};

Def: Definition = {
  <s: Schema> => Definition::Schema(s),
  <f: Fn> => Definition::Fn(f),
};

Schema: Schema = {
  "schema" <n: Name> <attrs: (<Attribute>)*> "end" => Schema {
      attrs: attrs
  }
};

Attribute: (String, Type) = {
  <n: Name> ":" <t: Type> =>  (n, t)
};

Fn: Function = {
    "fn" <n: Name> <args: (Arg*)> ":" <t: Type> ":=" <body: Term> "end" =>
      Function {
          name: n,
          ty: t,
          body: body,
      }
};

Arg: (Name, Type) = {
    "(" <n : Name> ":" <ty : Type> ")" => (n, ty)
};

Term: Term = {
    <f: Term> <g: Term0> => Term::App(Box::new(f), Box::new(g)),
    <m : Match> => Term::Match(Box::new(m.0), m.1),
    <t : Term0> => t,
    <e : Expr> => Term::Expr(e),
};

Term0: Term = {
  <n : Name> => Term::Var(n),
  "(" <t:Term> ")" => t,
};

Match: (Term, Vec<Case>) = {
  "match" <scrutinee: Term> "with" <cs: (Case)*> "end" =>
  (scrutinee, cs)
};

Case: Case = {
  "|" <p: Pattern> "=>" <body: Term> => Case {
      pattern: p,
      rhs: body,
  }
};

Pattern: Pattern = {
    <n : Name> <ns: PatternO*> => Pattern::Constructor(n, ns),
};

PatternO: Pattern = {
    <n : Name> => Pattern::Name(n),
    "(" <p: Pattern> ")" => p,
};

Type: Type = {
    <n: Name> => Type::Nominal(n)
};

Name: String = {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_owned()
};

Expr: Expr = {
    r"[1-9][0-9]+" => Expr::Int(i64::from_str(<>).unwrap())
};
