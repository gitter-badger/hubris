use ast::*;
use tok::{self, Tok};
use std::str::FromStr;
use unicode_xid::UnicodeXID;

grammar<'input>(text: &'input str)["LALR(1)"];

pub Module: Module =  {
  <lo:@L> "module" <n: Name> <ds: (Item)*> <hi:@R> =>
    Module {
        span: Span::new(lo, hi),
        name: n,
        items: ds,
    },
};

Item: Item = {
  <lo:@L> <d: ItemNoSpan> <hi:@R> => {
    let mut d = d;
    d.set_span(Span::new(lo, hi)); d
  }
};

ItemNoSpan: Item = {
  <d: Data> => Item::Data(d),
  <f: Fn> => Item::Fn(f),
  <e: Extern> => Item::Extern(e),
  <i: Import> => Item::Import(i),
};

Data: Data = {
 "inductive" <n: Name> <ps : Parameters> <ty: (":" Term)?> <attrs: (<Constructor>)*> "end" =>
  Data {
    span: Span::dummy(),
    name: n,
    parameters: ps,
    ty: ty.map(|t| t.1).unwrap_or(Term::Type),
    ctors: attrs,
  }
};

Constructor: (Name, Term) = {
    "|" <n: Name> ":" <t: Term> =>  (n, t)
};

Attribute: (Name, Term) = {
  <n: Name> ":" <t: Term> =>  (n, t)
};

Fn: Function = {
    "def" <n: Name> <args: (Arg*)> ":" <t: Term> ":=" <body: Term> "end" =>
      Function {
          span: Span::dummy(),
          name: n,
          args: args,
          ty: t,
          body: body,
      }
};

Extern: Extern = {
   "extern" <n : Name> ":" <t : Term> =>
    Extern {
      span: Span::dummy(),
      name: n,
      term: t,
    }
};

Import: Name = {
    "import" <n : Name> => n,
};

Arg: (Name, Term) = {
    "(" <n : Name> ":" <ty : Term> ")" => (n, ty)
};

Binder: (Name, Term) = {
    "(" <n : Name> ":" <ty : Term1> ")" => (n, ty)
};

Parameters: Vec<(Name, Term)> = {
  <params: Binder*> => params,
};

pub Term: Term = {
   "forall" <args: (Binder+)> "," <body: Term> => {
      let mut result = body; for (n, t) in args {
          result = Term::Forall {
            span: Span::dummy(),
            name: n,
            ty: Box::new(t),
            term: Box::new(result)
          };
      }
      result
  },
  "fun" <args: (Binder+)> ":" <t: Term> "=>" <body: Term> => Term::Lambda {
      span: Span::dummy(),
      args: args,
      ret_ty: Box::new(t),
      body: Box::new(body)
  },
  "let" <bindings: (Binding ",")+> "in" <body: Term> => {
      Term::Let {
          bindings: bindings.into_iter().map(|b| b.0).collect(),
          body: Box::new(body),
          span: Span::dummy(),
      }
   },
  <t: TermFnType> => t
};

Binding : (Name, Term, Term) = {
    <n: Name> ":" <ty: Term> ":=" <rhs: Term> => (n, ty, rhs)
};

TermFnType : Term = {
  <t1: Term1> "->" <t2: TermFnType> =>
      Term::Forall {
        span: Span::dummy(),
        name: Name::from_str(""),
        ty: Box::new(t1),
        term: Box::new(t2)
      },
  <t: Term1> => t
};

Term1: Term = {
    <f: Term1> <g: Term0> => Term::App {
      span: Span::dummy(),
      fun: Box::new(f),
      arg: Box::new(g)
    },
    <t : Term0> => t,
};


Term0: Term = {
  <lo:@L> <t: Term0US> <hi:@R>  => {
    let mut t = t;
    t.set_span(Span::new(lo, hi));
    t
  }
};

Term0US: Term = {
  <n : Name> => Term::Var { name: n },
  // <l : Literal> => Term::Literal {
  //    span: Span::dummy(),
  //    lit: l
  // },
  <m : Match> => Term::Match {
    span: Span::dummy(),
    scrutinee: Box::new(m.0),
    cases: m.1
  },
  // <s: r"\?[a-zA-Z_][a-zA-Z0-9_]*"> => {
  //    let name = Name::from_str(s);
  //
  //    Term::Metavar { name: name }
  // },
  "Type" => Term::Type,
  "(" <t:Term> ")" => t,
};

Match: (Term, Vec<Case>) = {
  "match" <scrutinee: Term> "with" <cs: (Case)*> "end"  =>
  (scrutinee, cs)
};

Case: Case = {
  <lo:@L> "|" <p: Pattern> "=>" <body: Term> <hi:@R> => Case {
      span: Span::new(lo, hi),
      pattern: p,
      rhs: body,
  }
};

Pattern: Pattern = {
    <n : Name> <ns: PatternO*> => Pattern::Constructor(n, ns),
};

PatternO: Pattern = {
    <n : Name> => Pattern::Name(n),
    "_" => Pattern::Placeholder,
    "(" <p: Pattern> ")" => p,
};

Name: Name = {
    <nk : NameKind> => {
        Name {
            span: Span::dummy(),
            repr: if nk.len() == 1 {
                let unqual = nk[0].clone();
                NameKind::Unqualified(unqual)
            } else {
                NameKind::Qualified(nk)
            }
        }
    },
};

NameKind: Vec<String> = {
    <prefix : NameKind> "." <end : "Id"> => {
        let mut prefix = prefix; prefix.push(end.to_string()); prefix
    },
    <s : "Id"> => vec![s.to_string()],
};

// Literal: Literal = {
//    r"\(\)" => Literal::Unit,
// };

extern {
    type Location = usize;
    type Error = tok::Error;
    enum Tok<'input> {
        "def" => Tok::Def,
        "end" => Tok::End,
        "extern" => Tok::Extern,
        "forall" => Tok::Forall,
        "fun" => Tok::Fun,
        "inductive" => Tok::Inductive,
        "in" => Tok::In,
        "import" => Tok::Import,
        "let" => Tok::Let,
        "match" => Tok::Match,
        "module" => Tok::Module,
        "pub" => Tok::Pub,
        "Type" => Tok::Type,
        "with" => Tok::With,
        "|" => Tok::Bar,
        ":" => Tok::Colon,
        ":=" => Tok::ColonEq,
        "(" => Tok::LeftParen,
        ")" => Tok::RightParen,
        "," => Tok::Comma,
        "=>" => Tok::FatArrow,
        "->" => Tok::Arrow,
        "_" => Tok::Underscore,
        "." => Tok::Period,
        "Comment" => Tok::Comment(<&'input str>),
        "Id" => Tok::Id(<&'input str>),
    }
}
