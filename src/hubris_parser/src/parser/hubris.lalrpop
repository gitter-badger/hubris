use ast::*;
use std::str::FromStr;

grammar;

pub Module: Module =  {
  <lo:@L> "module" <n: Name> <ds: (Def)*> <hi:@R> =>
    Module {
        span: Span::new(lo, hi),
        name: n,
        defs: ds,
    },
};

Def: Definition = {
  <d: Data> => Definition::Data(d),
  <f: Fn> => Definition::Fn(f),
  <c: Comment> => Definition::Comment(()),
  <e: Extern> => Definition::Extern(e),
};

Data: Data = {
<lo:@L> "data" <n: Name> <ty: (":" Term)?> <attrs: (<Constructor>)*> "end" <hi:@R> =>
  Data {
    span: Span::new(lo, hi),
    name: n,
    ty: ty.map(|t| t.1).unwrap_or(Term::Type),
    ctors: attrs,
  }
};

Constructor: (Name, Term) = {
    "|" <n: Name> ":" <t: Term> =>  (n, t)
};

Attribute: (Name, Term) = {
  <n: Name> ":" <t: Term> =>  (n, t)
};

Fn: Function = {
    <lo:@L> "fn" <n: Name> <args: (Arg*)> ":" <t: Term> ":=" <body: Term> "end" <hi:@R> =>
      Function {
          span: Span::new(lo, hi),
          name: n,
          args: args,
          ty: t,
          body: body,
      }
};

Extern: Extern = {
    <lo:@L> "extern" <n : Name> ":" <t : Term> <hi:@R> =>
    Extern {
      span: Span::new(lo, hi),
      name: n,
      term: t,
    }
};

Arg: (Name, Term) = {
    "(" <n : Name> ":" <ty : Term> ")" => (n, ty)
};

Binder: (Name, Term) = {
    "(" <n : Name> ":" <ty : Term1> ")" => (n, ty)
};


Term: Term = {
  "forall" <args: (Binder+)> "," <body: Term1> => {
      let mut result = body;
      for (n, t) in args {
          result = Term::Forall {
            span: Span::dummy(),
            name: n,
            ty: Box::new(t),
            term: Box::new(result)
          };
      }
      result
  },
  <t1: Term> "->" <t2: Term1> =>
      Term::Forall {
        span: Span::dummy(),
        name: Name::from_str(""),
        ty: Box::new(t1),
        term: Box::new(t2)
      },
  <t: Term1> => t
};

Term1: Term = {
    "fun" <args: (Arg+)> ":" <t: Term0> "=>" <body: Term0> => Term::Lambda {
        span: Span::dummy(),
        args: args,
        ret_ty: Box::new(t),
        body: Box::new(body)
    },
    <f: Term1> <g: Term0> => Term::App {
      span: Span::dummy(),
      fun: Box::new(f),
      arg: Box::new(g)
    },
    <t : Term0> => t,
};

Term0: Term = {
  <n : Name> => Term::Var { name: n },
  <l : Literal> => Term::Literal {
      span: Span::dummy(),
      lit: l
  },
  <m : Match> => Term::Match {
    span: Span::dummy(),
    scrutinee: Box::new(m.0),
    cases: m.1
  },
  <lo:@L> <s: r"\?[a-zA-Z_][a-zA-Z0-9_]*"> <hi:@R> => {
      let name = Name {
          span: Span::new(lo, hi),
          repr: s.to_owned(),
      };

      Term::Metavar { name: name }
  },
  "Type" => Term::Type,
  "(" <t:Term> ")" => t,
};

Match: (Term, Vec<Case>) = {
  "match" <scrutinee: Term> "with" <cs: (Case)*> "end"  =>
  (scrutinee, cs)
};

Case: Case = {
  <lo:@L> "|" <p: Pattern> "=>" <body: Term> <hi:@R> => Case {
      span: Span::new(lo, hi),
      pattern: p,
      rhs: body,
  }
};

Pattern: Pattern = {
    <n : Name> <ns: PatternO*> => Pattern::Constructor(n, ns),
};

PatternO: Pattern = {
    <n : Name> => Pattern::Name(n),
    "_" => Pattern::Placeholder,
    "(" <p: Pattern> ")" => p,
};

Name: Name = {
    <lo:@L> <s: r"[a-zA-Z_][a-zA-Z0-9_]*"> <hi:@R> => {
        Name {
            span: Span::new(lo, hi),
            repr: s.to_owned(),
        }
    }
};

Literal: Literal = {
    r"[1-9][0-9]+" => Literal::Int(i64::from_str(<>).unwrap()),
    r"\(\)" => Literal::Unit,
};

Comment: () = {
    r"--[^\n]*\n" => ()
};
